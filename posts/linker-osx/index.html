<!doctype html><html lang=zh-ch><head><title>OSX 上的动态链接 // AirChen Blog</title><link rel="shortcut icon" href=pikachu.ico><meta charset=utf-8><meta name=generator content="Hugo 0.104.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="AirChen"><meta name=description content><link rel=stylesheet href=https://blog.airchen-space.top/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css><meta name=twitter:card content="summary"><meta name=twitter:title content="OSX 上的动态链接"><meta name=twitter:description content="在 OSX 系统中，可执行文件的链接器涉及两种，ld（静态链接） 和 dyld（动态链接）。
静态链接器 ld 混合所有的目标文件，解决内部符号对外部的引用，并重定位这些符号，最后编译出一个复杂的可运行的文件。 静态链接器 ld (和 ld64)负责将源代码中的符号引用转换为间接的符号查找，供 dyld 以后使用。
dyld 动态链接库的工作如下：
内核为进程启动提供了一个非常简单的原始堆栈，动态链接的启动基于这个堆栈 递归、缓存式的加载执行文件所有依赖的动态库到内存空间，包括环境和可执行的运行路径 通过立即绑定非惰性符号并为惰性绑定设置必要的表，将这些库链接到可执行文件 为可执行文件运行静态初始化器 设置main函数的可执行参数，并调用它 在程序执行过程中，通过符号表，加载惰性绑定的调用；提供运行时动态加载服务（通过 dl()函数）；给gdb或其他的调试工具提供 Hook，来获取关键信息。 在main函数返回后，运行静态终止路由 一些情况下，在main函数返回后，调用 libSystem&rsquo;s 的 _exit 函数 启动： 一个新进程启动首先执行dyld的代码，内核通过系统调用命令 LC_LOAD_DYLINKER 来调用 __dyld_start ，从而启动 dyld 。__dyld_start 大致做了如下事情：
noreturn __dyld_start(stack mach_header *exec_mh, stack int argc, stack char **argv, stack char **envp, stack char **apple, stack char **STRINGS) { stack push 0 // debugger end of frames marker stack align 16 // SSE align stack uint64_t slide = __dyld_start - __dyld_start_static; void *glue = NULL; void *entry = dyldbootstrap::start(exec_mh, argc, argv, slide, ___dso_handle, &glue); if (glue) push glue // pretend the return address is a glue routine in dyld else stack restore // undo stack stuff we did before goto *entry(argc, argv, envp, apple); // never returns } "><meta property="og:title" content="OSX 上的动态链接"><meta property="og:description" content="在 OSX 系统中，可执行文件的链接器涉及两种，ld（静态链接） 和 dyld（动态链接）。
静态链接器 ld 混合所有的目标文件，解决内部符号对外部的引用，并重定位这些符号，最后编译出一个复杂的可运行的文件。 静态链接器 ld (和 ld64)负责将源代码中的符号引用转换为间接的符号查找，供 dyld 以后使用。
dyld 动态链接库的工作如下：
内核为进程启动提供了一个非常简单的原始堆栈，动态链接的启动基于这个堆栈 递归、缓存式的加载执行文件所有依赖的动态库到内存空间，包括环境和可执行的运行路径 通过立即绑定非惰性符号并为惰性绑定设置必要的表，将这些库链接到可执行文件 为可执行文件运行静态初始化器 设置main函数的可执行参数，并调用它 在程序执行过程中，通过符号表，加载惰性绑定的调用；提供运行时动态加载服务（通过 dl()函数）；给gdb或其他的调试工具提供 Hook，来获取关键信息。 在main函数返回后，运行静态终止路由 一些情况下，在main函数返回后，调用 libSystem&rsquo;s 的 _exit 函数 启动： 一个新进程启动首先执行dyld的代码，内核通过系统调用命令 LC_LOAD_DYLINKER 来调用 __dyld_start ，从而启动 dyld 。__dyld_start 大致做了如下事情：
noreturn __dyld_start(stack mach_header *exec_mh, stack int argc, stack char **argv, stack char **envp, stack char **apple, stack char **STRINGS) { stack push 0 // debugger end of frames marker stack align 16 // SSE align stack uint64_t slide = __dyld_start - __dyld_start_static; void *glue = NULL; void *entry = dyldbootstrap::start(exec_mh, argc, argv, slide, ___dso_handle, &glue); if (glue) push glue // pretend the return address is a glue routine in dyld else stack restore // undo stack stuff we did before goto *entry(argc, argv, envp, apple); // never returns } "><meta property="og:type" content="article"><meta property="og:url" content="https://blog.airchen-space.top/posts/linker-osx/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-06-09T17:19:51+08:00"><meta property="article:modified_time" content="2020-06-09T17:19:51+08:00"></head><body><header class=app-header><a href=https://blog.airchen-space.top/><img class=app-header-avatar src=/log.jpeg alt=AirChen></a><h1>AirChen Blog</h1><nav class=app-header-menu><a class=app-header-menu-item href=/>Home</a>
-
<a class=app-header-menu-item href=/daily/>Tags</a>
-
<a class=app-header-menu-item href=/about/>About</a></nav><p>以最放松的心态对待一切艰难</p><div class=app-header-social><a href=https://github.com/AirChen target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>My Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=renzhichen2012@163.com target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-mail"><title>My Email</title><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>OSX 上的动态链接</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Jun 9, 2020</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>1 min read</div></div></header><div class=post-content><p>在 OSX 系统中，可执行文件的链接器涉及两种，ld（静态链接） 和 dyld（动态链接）。</p><p>静态链接器 ld 混合所有的目标文件，解决内部符号对外部的引用，并重定位这些符号，最后编译出一个复杂的可运行的文件。
静态链接器 ld (和 ld64)负责将源代码中的符号引用转换为间接的符号查找，供 dyld 以后使用。</p><p>dyld 动态链接库的工作如下：</p><ol><li>内核为进程启动提供了一个非常简单的原始堆栈，动态链接的启动基于这个堆栈</li><li>递归、缓存式的加载执行文件所有依赖的动态库到内存空间，包括环境和可执行的运行路径</li><li>通过立即绑定非惰性符号并为惰性绑定设置必要的表，将这些库链接到可执行文件</li><li>为可执行文件运行静态初始化器</li><li>设置main函数的可执行参数，并调用它</li><li>在程序执行过程中，通过符号表，加载惰性绑定的调用；提供运行时动态加载服务（通过 dl()函数）；给gdb或其他的调试工具提供 Hook，来获取关键信息。</li><li>在main函数返回后，运行静态终止路由</li><li>一些情况下，在main函数返回后，调用 libSystem&rsquo;s 的 _exit 函数</li></ol><p>启动：
一个新进程启动首先执行dyld的代码，内核通过系统调用命令 LC_LOAD_DYLINKER 来调用 __dyld_start ，从而启动 dyld 。__dyld_start 大致做了如下事情：</p><pre tabindex=0><code>noreturn __dyld_start(stack mach_header *exec_mh, stack int argc, stack char **argv, stack char **envp, stack char **apple, stack char **STRINGS)
    {
        stack push 0 // debugger end of frames marker
        stack align 16 // SSE align stack
        uint64_t slide = __dyld_start - __dyld_start_static;
        void *glue = NULL;
        void *entry = dyldbootstrap::start(exec_mh, argc, argv, slide, ___dso_handle, &amp;glue);
        if (glue)
            push glue // pretend the return address is a glue routine in dyld
        else
            stack restore // undo stack stuff we did before
        goto *entry(argc, argv, envp, apple); // never returns
    }
</code></pre></div><div class=post-footer></div></article></main></body></html>