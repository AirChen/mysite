<!doctype html><html lang=zh-ch>
<head>
<title>UICollectionViewFlowLayout相关 // AirChen Blog</title><link rel="shortcut icon" href=pikachu.ico>
<meta charset=utf-8>
<meta name=generator content="Hugo 0.93.0">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=author content="AirChen">
<meta name=description content>
<link rel=stylesheet href=https://blog.airchen-space.top/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css>
<meta name=twitter:card content="summary">
<meta name=twitter:title content="UICollectionViewFlowLayout相关">
<meta name=twitter:description content="子类化UICollectionViewFlowLayout可以让UICollectionView实现许多精彩的布局，在实际的项目中子类化UICollectionViewFlowLayout得到了广泛的应用。
引入 以下是一些实例：
可见借助于UICollectionViewFlowLayout可以让UICollectionView展示丰富的界面效果。
基本用法 涉及到的类有：
 UICollectionViewFlowLayout => 负责item的布局，也可实现切换item的动画 UICollectionView => 展示的总视图 UICollectionViewCell => 每个item 协议有：
 UICollectionViewDelegate UICollectionViewDataSource 用已经子类化的UICollectionViewFlowLayout创建一个UICollectionView
 self.collectionView = [[UICollectionView alloc] initWithFrame:CGRectZero collectionViewLayout:self.smallLayout]; 在数据源方法中实现item的数量与每个item的创建
 - (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section; - (__kindof UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath; 其中UICollectionViewCell可以子类化，添加一些label或者ImageView。
可以简单的子类化一个UICollectionViewFlowLayout，只需复写以下init方法：
 -(id)init { if (!(self = [super init])) return nil; self.itemSize = CGSizeMake(30, 30); self.sectionInset = UIEdgeInsetsMake(10, 10, 10, 10); self.minimumInteritemSpacing = 10.0f; self.minimumLineSpacing = 10.0f; return self; } 此外UICollectionViewFlowLayout还包括一些其他的方法，可以根据需求来选择：">
<meta property="og:title" content="UICollectionViewFlowLayout相关">
<meta property="og:description" content="子类化UICollectionViewFlowLayout可以让UICollectionView实现许多精彩的布局，在实际的项目中子类化UICollectionViewFlowLayout得到了广泛的应用。
引入 以下是一些实例：
可见借助于UICollectionViewFlowLayout可以让UICollectionView展示丰富的界面效果。
基本用法 涉及到的类有：
 UICollectionViewFlowLayout => 负责item的布局，也可实现切换item的动画 UICollectionView => 展示的总视图 UICollectionViewCell => 每个item 协议有：
 UICollectionViewDelegate UICollectionViewDataSource 用已经子类化的UICollectionViewFlowLayout创建一个UICollectionView
 self.collectionView = [[UICollectionView alloc] initWithFrame:CGRectZero collectionViewLayout:self.smallLayout]; 在数据源方法中实现item的数量与每个item的创建
 - (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section; - (__kindof UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath; 其中UICollectionViewCell可以子类化，添加一些label或者ImageView。
可以简单的子类化一个UICollectionViewFlowLayout，只需复写以下init方法：
 -(id)init { if (!(self = [super init])) return nil; self.itemSize = CGSizeMake(30, 30); self.sectionInset = UIEdgeInsetsMake(10, 10, 10, 10); self.minimumInteritemSpacing = 10.0f; self.minimumLineSpacing = 10.0f; return self; } 此外UICollectionViewFlowLayout还包括一些其他的方法，可以根据需求来选择：">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.airchen-space.top/posts/flowlayout/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-02-05T17:19:51+08:00">
<meta property="article:modified_time" content="2017-02-05T17:19:51+08:00">
</head><body>
<header class=app-header>
<a href=https://blog.airchen-space.top/><img class=app-header-avatar src=/log.jpeg alt=AirChen></a>
<h1>AirChen Blog</h1><nav class=app-header-menu>
<a class=app-header-menu-item href=/>Home</a>
-
<a class=app-header-menu-item href=/daily/>Tags</a>
-
<a class=app-header-menu-item href=/about/>About</a>
</nav><p>以最放松的心态对待一切艰难</p><div class=app-header-social>
<a href=https://github.com/AirChen target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>My Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a>
<a href=renzhichen2012@163.com target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-mail"><title>My Email</title><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>
</a>
</div></header><main class=app-container>
<article class=post>
<header class=post-header>
<h1 class=post-title>UICollectionViewFlowLayout相关</h1><div class=post-meta>
<div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
Feb 5, 2017
</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
2 min read
</div></div></header><div class=post-content>
<p>子类化UICollectionViewFlowLayout可以让UICollectionView实现许多精彩的布局，在实际的项目中子类化UICollectionViewFlowLayout得到了广泛的应用。</p><h3 id=引入>引入</h3><p>以下是一些实例：</p><p><img src=images/1.png alt>
<img src=images/2.png alt></p><p><img src=images/demo.gif alt></p><p><img src=images/demo1.gif alt></p><p>可见借助于UICollectionViewFlowLayout可以让UICollectionView展示丰富的界面效果。</p><h3 id=基本用法>基本用法</h3><p>涉及到的类有：</p><pre tabindex=0><code>     UICollectionViewFlowLayout =&gt; 负责item的布局，也可实现切换item的动画
     UICollectionView =&gt; 展示的总视图
     UICollectionViewCell =&gt; 每个item
</code></pre><p>协议有：</p><pre tabindex=0><code>    UICollectionViewDelegate
    UICollectionViewDataSource
</code></pre><p>用已经子类化的UICollectionViewFlowLayout创建一个UICollectionView</p><pre tabindex=0><code>    self.collectionView = [[UICollectionView alloc] initWithFrame:CGRectZero collectionViewLayout:self.smallLayout];
</code></pre><p>在数据源方法中实现item的数量与每个item的创建</p><pre tabindex=0><code>    - (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section;

    - (__kindof UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath;
</code></pre><p>其中UICollectionViewCell可以子类化，添加一些label或者ImageView。</p><p>可以简单的子类化一个UICollectionViewFlowLayout，只需复写以下init方法：</p><pre tabindex=0><code>    -(id)init
    {
        if (!(self = [super init])) return nil;
        self.itemSize = CGSizeMake(30, 30);
        self.sectionInset = UIEdgeInsetsMake(10, 10, 10, 10);
        self.minimumInteritemSpacing = 10.0f;
        self.minimumLineSpacing = 10.0f;
        return self;
    }
</code></pre><p>此外UICollectionViewFlowLayout还包括一些其他的方法，可以根据需求来选择：</p><pre tabindex=0><code>    -(CGSize)collectionViewContentSize
    //返回contentsize的总大小
    -(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds
    //自定义布局必须YES
    - (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)path{}//返回每个cell的布局属性
    -(NSArray*)layoutAttributesForElementsInRect:(CGRect)rect
    //返回所有cell的布局属性
</code></pre><p><a href=https://github.com/ashfurrow/UICollectionViewFlowLayoutExample>参考实例</a></p><h3 id=瀑布流>瀑布流</h3><p>与基础部分的使用基本一致，UICollectionViewFlowLayout的子类设计思路如下：
每个item对应一个UICollectionViewLayoutAttributes属性，这里要注意该属性中的frame，它负责每个item的布局，瀑布流的布局是便利一个数据源数组，数组中有每个item的长宽，从最上层开始，往下进行布局。设置两个状态量，分别保存每列的累加长度和item个数，将从数组中遍历到的item数据的高度加到最短的列中。</p><p>用到了两个关键的方法：</p><pre tabindex=0><code>    - (void)prepareLayout;
    - (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect;
</code></pre><p>关键代码：</p><pre tabindex=0><code>    // 遍历 goodsList 数组计算相关的属性
    NSInteger index = 0;
    NSMutableArray *attributesArray = [NSMutableArray arrayWithCapacity:self.goodsList.count];
    for (LNGood *good in self.goodsList) {

        // 建立布局属性
        NSIndexPath *indexPath = [NSIndexPath indexPathForItem:index inSection:0];
        UICollectionViewLayoutAttributes *attributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];
        // 找出最短列号
        NSInteger column = [self shortestColumn:columnHeight];
        // 数据追加在最短列
        columnItemCount[column]++;
        // X值
        CGFloat itemX = (itemWidth + self.minimumInteritemSpacing) * column + self.sectionInset.left;
        // Y值
        CGFloat itemY = columnHeight[column];
        // 等比例缩放 计算item的高度
        CGFloat itemH = good.h * itemWidth / good.w;
        // 设置frame
        attributes.frame = CGRectMake(itemX, itemY, itemWidth, itemH);
        [attributesArray addObject:attributes];

        // 累加列高
        columnHeight[column] += itemH + self.minimumLineSpacing;

        index++;
    }
</code></pre><p><a href=https://github.com/zhouande/TLCollectionWaterfallFlow>视图内容的高度固定</a></p><p><a href=https://github.com/lengmolehongyan/WaterfallFlowDemo>视图内容高度无限，向下刷新</a></p><h3 id=动画效果>动画效果</h3><p>UICollectionViewLayoutAttributes的frame属性负责item的布局，transform3D属性可以做动画效果</p><pre tabindex=0><code>    if (self.style == QMUICollectionViewPagingLayoutStyleScale) {

        CGFloat distanceForMinimumScale = itemSize.width + self.minimumLineSpacing;
        CGFloat distanceForMaximumScale = 0.0;

        for (UICollectionViewLayoutAttributes *attributes in resultAttributes) {
            CGFloat scale = 0;
            CGFloat distance = fabs(offset - attributes.center.x);
            if (distance &gt;= distanceForMinimumScale) {
                scale = self.minimumScale;
            } else if (distance == distanceForMaximumScale) {
                scale = self.maximumScale;
            } else {
                scale = self.minimumScale + (distanceForMinimumScale - distance) * (self.maximumScale - self.minimumScale) / (distanceForMinimumScale - distanceForMaximumScale);
            }
            attributes.transform3D = CATransform3DMakeScale(scale, scale, 1);
            attributes.zIndex = 1;
        }
        return resultAttributes;
    }
</code></pre><p>其中offset为当前滚动位置的可视区域的中心点。</p><p><a href=https://github.com/QMUI/QMUIDemo_iOS/blob/master/QMUI/QMUIKit/UIKitExtensions/QMUICollectionViewPagingLayout.m>QMUI 的 QMUICollectionViewPagingLayout支持旋转和放大效果</a></p></div><div class=post-footer>
</div></article></main></body></html>