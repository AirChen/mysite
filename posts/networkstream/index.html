<!doctype html><html lang=zh-ch><head><title>一种支持多线程并发读写的数据模型 // AirChen Blog</title><link rel="shortcut icon" href=pikachu.ico><meta charset=utf-8><meta name=generator content="Hugo 0.108.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="AirChen"><meta name=description content><link rel=stylesheet href=https://blog.airchen-space.top/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css><meta name=twitter:card content="summary"><meta name=twitter:title content="一种支持多线程并发读写的数据模型"><meta name=twitter:description content="在实际的开发中，常常会遇到这种场景，一个模块产生数据，另外一个模块处理数据。无论是为了模块间的解耦或者是并发处理，我们都会在生成和处理数据的模块之间放置缓存区，作为生成与处理之间的数据仓库。这类模型就是生产者与消费者模型。
生产者和消费者往往是并发的多个线程，它们可能同时对一块数据进行增加与删除操作。一个比较常见的情形是在对网络数据的处理上，我们想把从网络下载的数据进行一个高效的处理，又不想保存在本地磁盘上。这个时候就会考虑用一个内存变量对数据进行缓存，同时需要满足以下这些条件：
线程安全，不能让一个线程正在对数据进行操作的时候，被其他线程打断。 在数据被处理完后，变量要及时被释放，减少内存占用。 写入操作快于读出操作时，要限制一个最大的变量空间并阻塞写入线程，等待读出操作，防止内存占用过大，将app杀死。 读出操作快于写入操作时，要在数据为空时，阻塞读出线程，等待写入线程的数据写入。 根据这些要点，本文设计了一种高效的数据仓库，该数据仓库可以对二进制数据进行线程安全的读写操作，读出数据后，立马释放读出的资源，内存占用少，没有磁盘操作，所以效率会很高。
仓库链接
该数据仓库的主体以一个可变数组组成，数组中的每个元素为一定长的二进制数据NSData，通过读标志位和写标志位，记录该结构体类数据的读写状态，当数据被读出，且正好凑出整数个NSData，则将这些NSData的内存进行释放，更新读写标志位。
{:width=&ldquo;70%&rdquo; height=&ldquo;70%&rdquo; align=&ldquo;center&rdquo;}
这里起关键性作用的是记录读写状态的读写标志位，它们分为readIndex、readInnerIndex、writeIndex和writeInnerIndex，刚开始数据仓库中没有数据时，各个状态为赋值为-1。当开始写入数据，该数据结构会根据写入数据的长度计算出一个结束的位置，然后在结束为与当前的writeIndex和writeInnerIndex之间，写入数据。最后用结束位更新写标志位。
读操作与写操作类似，会先根据读长度来计算出一个读出结束标志位，然后把当前读标志位到读出结束标志位之间的数据写入一个读出的buffer，凑齐整数个NSData则删除，最后用读出结束标志位来更新度标志位，同时更具数组中删除的NSData个数，调整读写标志位中的XXIndex标志位。
同步锁使用的@synchronized，在数据读完后，有加等待，让数据继续写入，直到写入线程结束。"><meta property="og:title" content="一种支持多线程并发读写的数据模型"><meta property="og:description" content="在实际的开发中，常常会遇到这种场景，一个模块产生数据，另外一个模块处理数据。无论是为了模块间的解耦或者是并发处理，我们都会在生成和处理数据的模块之间放置缓存区，作为生成与处理之间的数据仓库。这类模型就是生产者与消费者模型。
生产者和消费者往往是并发的多个线程，它们可能同时对一块数据进行增加与删除操作。一个比较常见的情形是在对网络数据的处理上，我们想把从网络下载的数据进行一个高效的处理，又不想保存在本地磁盘上。这个时候就会考虑用一个内存变量对数据进行缓存，同时需要满足以下这些条件：
线程安全，不能让一个线程正在对数据进行操作的时候，被其他线程打断。 在数据被处理完后，变量要及时被释放，减少内存占用。 写入操作快于读出操作时，要限制一个最大的变量空间并阻塞写入线程，等待读出操作，防止内存占用过大，将app杀死。 读出操作快于写入操作时，要在数据为空时，阻塞读出线程，等待写入线程的数据写入。 根据这些要点，本文设计了一种高效的数据仓库，该数据仓库可以对二进制数据进行线程安全的读写操作，读出数据后，立马释放读出的资源，内存占用少，没有磁盘操作，所以效率会很高。
仓库链接
该数据仓库的主体以一个可变数组组成，数组中的每个元素为一定长的二进制数据NSData，通过读标志位和写标志位，记录该结构体类数据的读写状态，当数据被读出，且正好凑出整数个NSData，则将这些NSData的内存进行释放，更新读写标志位。
{:width=&ldquo;70%&rdquo; height=&ldquo;70%&rdquo; align=&ldquo;center&rdquo;}
这里起关键性作用的是记录读写状态的读写标志位，它们分为readIndex、readInnerIndex、writeIndex和writeInnerIndex，刚开始数据仓库中没有数据时，各个状态为赋值为-1。当开始写入数据，该数据结构会根据写入数据的长度计算出一个结束的位置，然后在结束为与当前的writeIndex和writeInnerIndex之间，写入数据。最后用结束位更新写标志位。
读操作与写操作类似，会先根据读长度来计算出一个读出结束标志位，然后把当前读标志位到读出结束标志位之间的数据写入一个读出的buffer，凑齐整数个NSData则删除，最后用读出结束标志位来更新度标志位，同时更具数组中删除的NSData个数，调整读写标志位中的XXIndex标志位。
同步锁使用的@synchronized，在数据读完后，有加等待，让数据继续写入，直到写入线程结束。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.airchen-space.top/posts/networkstream/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-12-03T17:19:51+08:00"><meta property="article:modified_time" content="2017-12-03T17:19:51+08:00"></head><body><header class=app-header><a href=https://blog.airchen-space.top/><img class=app-header-avatar src=/log.jpeg alt=AirChen></a><h1>AirChen Blog</h1><nav class=app-header-menu><a class=app-header-menu-item href=/>Home</a>
-
<a class=app-header-menu-item href=/daily/>Tags</a>
-
<a class=app-header-menu-item href=/about/>About</a></nav><p>以最放松的心态对待一切艰难</p><div class=app-header-social><a href=https://github.com/AirChen target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>My Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=renzhichen2012@163.com target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-mail"><title>My Email</title><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>一种支持多线程并发读写的数据模型</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Dec 3, 2017</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>1 min read</div></div></header><div class=post-content><p>在实际的开发中，常常会遇到这种场景，一个模块产生数据，另外一个模块处理数据。无论是为了模块间的解耦或者是并发处理，我们都会在生成和处理数据的模块之间放置缓存区，作为生成与处理之间的数据仓库。这类模型就是生产者与消费者模型。</p><p>生产者和消费者往往是并发的多个线程，它们可能同时对一块数据进行增加与删除操作。一个比较常见的情形是在对网络数据的处理上，我们想把从网络下载的数据进行一个高效的处理，又不想保存在本地磁盘上。这个时候就会考虑用一个内存变量对数据进行缓存，同时需要满足以下这些条件：</p><ol><li>线程安全，不能让一个线程正在对数据进行操作的时候，被其他线程打断。</li><li>在数据被处理完后，变量要及时被释放，减少内存占用。</li><li>写入操作快于读出操作时，要限制一个最大的变量空间并阻塞写入线程，等待读出操作，防止内存占用过大，将app杀死。</li><li>读出操作快于写入操作时，要在数据为空时，阻塞读出线程，等待写入线程的数据写入。</li></ol><p>根据这些要点，本文设计了一种高效的数据仓库，该数据仓库可以对二进制数据进行线程安全的读写操作，读出数据后，立马释放读出的资源，内存占用少，没有磁盘操作，所以效率会很高。</p><p><a href=https://github.com/AirChen/NetworkStream>仓库链接</a></p><p>该数据仓库的主体以一个可变数组组成，数组中的每个元素为一定长的二进制数据NSData，通过读标志位和写标志位，记录该结构体类数据的读写状态，当数据被读出，且正好凑出整数个NSData，则将这些NSData的内存进行释放，更新读写标志位。</p><p><img src=images/struct.jpg alt>{:width=&ldquo;70%&rdquo; height=&ldquo;70%&rdquo; align=&ldquo;center&rdquo;}</p><p>这里起关键性作用的是记录读写状态的读写标志位，它们分为readIndex、readInnerIndex、writeIndex和writeInnerIndex，刚开始数据仓库中没有数据时，各个状态为赋值为-1。当开始写入数据，该数据结构会根据写入数据的长度计算出一个结束的位置，然后在结束为与当前的writeIndex和writeInnerIndex之间，写入数据。最后用结束位更新写标志位。</p><p>读操作与写操作类似，会先根据读长度来计算出一个读出结束标志位，然后把当前读标志位到读出结束标志位之间的数据写入一个读出的buffer，凑齐整数个NSData则删除，最后用读出结束标志位来更新度标志位，同时更具数组中删除的NSData个数，调整读写标志位中的XXIndex标志位。</p><p>同步锁使用的@synchronized，在数据读完后，有加等待，让数据继续写入，直到写入线程结束。</p></div><div class=post-footer></div></article></main></body></html>