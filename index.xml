<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AirChen Blog</title><link>https://blog.airchen-space.top/</link><description>Recent content on AirChen Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-ch</language><lastBuildDate>Tue, 09 Jun 2020 17:19:51 +0800</lastBuildDate><atom:link href="https://blog.airchen-space.top/index.xml" rel="self" type="application/rss+xml"/><item><title>OSX 上的动态链接</title><link>https://blog.airchen-space.top/posts/linker-osx/</link><pubDate>Tue, 09 Jun 2020 17:19:51 +0800</pubDate><guid>https://blog.airchen-space.top/posts/linker-osx/</guid><description>在 OSX 系统中，可执行文件的链接器涉及两种，ld（静态链接） 和 dyld（动态链接）。
静态链接器 ld 混合所有的目标文件，解决内部符号对外部的引用，并重定位这些符号，最后编译出一个复杂的可运行的文件。 静态链接器 ld (和 ld64)负责将源代码中的符号引用转换为间接的符号查找，供 dyld 以后使用。
dyld 动态链接库的工作如下：
内核为进程启动提供了一个非常简单的原始堆栈，动态链接的启动基于这个堆栈 递归、缓存式的加载执行文件所有依赖的动态库到内存空间，包括环境和可执行的运行路径 通过立即绑定非惰性符号并为惰性绑定设置必要的表，将这些库链接到可执行文件 为可执行文件运行静态初始化器 设置main函数的可执行参数，并调用它 在程序执行过程中，通过符号表，加载惰性绑定的调用；提供运行时动态加载服务（通过 dl()函数）；给gdb或其他的调试工具提供 Hook，来获取关键信息。 在main函数返回后，运行静态终止路由 一些情况下，在main函数返回后，调用 libSystem&amp;rsquo;s 的 _exit 函数 启动： 一个新进程启动首先执行dyld的代码，内核通过系统调用命令 LC_LOAD_DYLINKER 来调用 __dyld_start ，从而启动 dyld 。__dyld_start 大致做了如下事情：
noreturn __dyld_start(stack mach_header *exec_mh, stack int argc, stack char **argv, stack char **envp, stack char **apple, stack char **STRINGS) { stack push 0 // debugger end of frames marker stack align 16 // SSE align stack uint64_t slide = __dyld_start - __dyld_start_static; void *glue = NULL; void *entry = dyldbootstrap::start(exec_mh, argc, argv, slide, ___dso_handle, &amp;amp;glue); if (glue) push glue // pretend the return address is a glue routine in dyld else stack restore // undo stack stuff we did before goto *entry(argc, argv, envp, apple); // never returns }</description></item><item><title>Objective-C 字面量的内存管理</title><link>https://blog.airchen-space.top/posts/literal/</link><pubDate>Sun, 07 Jun 2020 17:19:51 +0800</pubDate><guid>https://blog.airchen-space.top/posts/literal/</guid><description>起因：
__auto_type __weak wStr = @&amp;#34;123&amp;#34;; __auto_type __weak owStr = [[NSString alloc] initWithString:@&amp;#34;one two three&amp;#34;]; 发现通过字面量的形式给 __weak 变量赋值，不会出现警告。
我们知道，__weak 在Objc的内存管理里是弱指针，仅指向但不拥有对象，一旦所指向的对象释放了，__weak 变量也会被设置为 nil 。所以常常用于解决循环引用。
根据引用计数的原理，一个对象没有变量去引用了，就会立即被释放掉，而用 __weak 变量去指向一个对象，同样也不会引起该对象引用计数的增加。
实验一下：
__auto_type __weak obj = [[NSObject alloc] init]; NSLog(@&amp;#34;%@&amp;#34;, obj); __auto_type objs = [[NSObject alloc] init]; NSLog(@&amp;#34;%@&amp;#34;, objs); 控制台输出：
2020-06-07 07:55:17.812027+0800 debug[2495:33225] (null) 2020-06-07 07:55:17.812886+0800 debug[2495:33225] &amp;lt;NSObject: 0x101004d60&amp;gt; 可见 __weak 变量并不能保留对象，在编译器中也会出现编译警告 那么为何什么字面量的形式赋值时，不会出现该警告？难道字面量创建对象不会被释放？
我们将代码编译为C++代码，来分析结构
clang --rewrite-objc main.m 删去多余代码，我们得到如下主干部分：
static __NSConstantStringImpl __NSConstantStringImpl__var_mi_0 __attribute__ ((section (&amp;#34;__DATA, __cfstring&amp;#34;))) = {__CFConstantStringClassReference,0x000007c8,&amp;#34;one two three&amp;#34;,13}; static __NSConstantStringImpl __NSConstantStringImpl__var_mi_1 __attribute__ ((section (&amp;#34;__DATA, __cfstring&amp;#34;))) = {__CFConstantStringClassReference,0x000007c8,&amp;#34;one two three&amp;#34;,13}; int main(int argc, const char * argv[]) { /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; __auto_type wStr = (NSString *)&amp;amp;__NSConstantStringImpl__var_mi_0; __auto_type owStr = ((NSString *(*)(id, SEL, NSString * _Nonnull))(void *)objc_msgSend)((id)((NSString *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&amp;#34;NSString&amp;#34;), sel_registerName(&amp;#34;alloc&amp;#34;)), sel_registerName(&amp;#34;initWithString:&amp;#34;), (NSString *)&amp;amp;__NSConstantStringImpl__var_mi_1); } return 0; } 字面量赋值，其实是将一个静态数据赋值给了 wStr，内存在编译后的二进制中，相当于静态变量。而通过代码结构创建的（有警告的那种），会走消息传递，从而内存交由 ARC 来管理。</description></item><item><title>一个简单的垃圾回收器（翻译）</title><link>https://blog.airchen-space.top/posts/garbagecollector/</link><pubDate>Sun, 10 May 2020 17:19:51 +0800</pubDate><guid>https://blog.airchen-space.top/posts/garbagecollector/</guid><description>垃圾回收是编程中鲨鱼出没最多的领域之一，但是在这篇文章中，我会给你一个不错的儿童游泳池，你可以在里面游泳。 (可能还有鲨鱼在里面，但至少它会比较浅。)
减少废物，循环再用，循环再造 垃圾回收背后的基本思想是，该语言(在大多数情况下)似乎可以访问无限内存。 开发人员只需要保持分配、分配和分配，就像魔术一样，它永远不会失败。
当然，机器没有无限的内存。 所以实现的方式是，当它正在运行时内存空间不够并需要分配一点内存，它会收集垃圾。
此上下文中的“垃圾”是指它以前分配的不需要再被使用的内存。 为了让无限记忆的想法实现，语言必须在处理“不再被使用”内存时非常安全。 如果随机对象在程序试图访问它们时就开始被回收，那就没有意思了。
为了能够实现可回收，这种语言必须确保程序无法再次使用这个对象。 如果它不能得到对象的引用，那么它显然不能再次使用它。 因此，“在用”的定义实际上非常简单:
任何由作用域中的变量引用的对象都在使用中。 任何被另一个正在使用的对象引用的对象都在使用中。 第二条规则是递归规则。
如果对象 a 被一个变量引用，并且它有一些引用对象 b 的字段，那么 b 就被使用了，因为你可以通过 a 找到它。 最终的结果是一个可到达所有对象的引用图，你可以从一个变量开始遍历所有对象。 对于程序来说，任何不在这个图中的对象都是死的，它的内存已经过期，可以收获了。
标记和清扫 有许多不同的方法可以实现查找和回收所有未使用对象的过程，但有史以来为此发明的最简单也是最早的算法被称为“标记-清除”。 它是由 John McCarthy 发明的，他发明了 Lisp 和 beards，所以现在实现垃圾回收器就像是在和一个老神交流，但是希望不是以 Lovecraftian 的方式，以你的头脑和视网膜被炸得干干净净结束。
“标记-清除”的工作原理几乎和我们对可达性的定义一模一样:
从根开始，遍历整个对象图。 每次你到达一个对象时，在它上面设置一个“标记”位为 true。
完成之后，找到所有标记位未设置的对象并删除它们。
A pair of objects 在我们开始实现这两个步骤之前，让我们先做一些准备工作。 我们实际上不会为某种语言实现一个解释器 ーー 没有解析功能、字节码或其他任何愚蠢的东西ーー但我们确实需要一些最少量的代码来创建一些垃圾来进行收集。
让我们假设我们正在为一种小语言写一个解释器。 它是动态类型的，有两种类型的对象: int 和 pairs。 这里有一个枚举来标识一个对象的类型:
{% highlight c %} typedef enum { OBJ_INT, OBJ_PAIR } ObjectType; {% endhighlight %}</description></item><item><title>链接器的初学者指南（翻译）</title><link>https://blog.airchen-space.top/posts/linker/</link><pubDate>Sun, 12 Apr 2020 17:19:51 +0800</pubDate><guid>https://blog.airchen-space.top/posts/linker/</guid><description>命名：C源文件中都有什么？ 这部分是介绍 C源文件的组成，如果你熟悉下列代码，可以进入下一小结。
第一步需要区分 申明(declarations) 和 定义(definitions), 定义关联一个名字并且有代码或者数据来实现这个名字：
1. 定义一个变量，让编译器给该变量分配空间，可能给这个空间分配一个值。 2. 定义一个函数，让编译器给这个函数产生代码。 声明告诉 C 编译器在当前程序中有这个定义，可能在别的 C源文件中。（注意：定义有时会看成声明，当其位置在声明的地方时）。
接下来是对于变量，有两种类型定义：
1. 全部变量，存在于整个程序的生命周期中(&amp;quot;static extent&amp;quot;)，在很多不同的函数中可以获取到。 2. 局部变量，仅存在于一个特定的函数中(&amp;quot;local extent&amp;quot;)，仅通过这个函数才能获取到这个变量。 (这里的获取，是说可以引用这个变量) 这里有两个特例：
1. 静态局部变量，实际上是全局变量，因为它存在于整个生命周期，但只能从这个特定函数获取。 2. 同样的静态全局变量也可以看成全局变量，虽然只能在它定义的 C文件中获取到。 这里我们把焦点放在了关键字 &amp;ldquo;静态(static)&amp;rdquo; 上，需要指出的是将一个函数变为静态函数，可以减少其他地方引用该函数的行数(特别是通过同一个 C文件的不同函数) -&amp;gt; 此处我的理解是函数的定义代码被共享了，不会在引用的地方再展开函数。
对于全局变量和局部变量定义，我们还可以区分变量是否初始化(也就是说，与特定名称关联的空间是否预先填充了特定值)。
最后，我们可以通过 malloc 或者 new 把信息动态地存储到内存，没有办法通过名称直接访问分配的内存，所以我们必须通过指针(一个命名变量保留着一段内存地址)。这个内存地址可以通过 free 或者 delete 来销毁，所以这被引用的空间有个动态的范围(dynamic extent)。
总结一下：
{% highlight cpp %} /* This is the definition of a uninitialized global variable */ int x_global_uninit;
/* This is the definition of a initialized global variable */ int x_global_init = 1;</description></item><item><title>LLVM 使用手册</title><link>https://blog.airchen-space.top/posts/llvm/</link><pubDate>Sun, 09 Feb 2020 17:19:51 +0800</pubDate><guid>https://blog.airchen-space.top/posts/llvm/</guid><description>简介 LLVM 是一个发展中的前言编辑器技术框架，它易于扩展并设计成多个库的形式，可以为编译器开发者提供流畅的体验，并能使编译器开发所涉及的学习过程变得非常流畅。
LLVM 架构特性 C++ 语言实现 前端与后端分离，支持多种前端和后端，使用中间代码 IR 进行衔接 第一个 Release 版本发布于 2003 年，代码开源 提供了很多工具用于编译和优化代码 与 GCC 相比，编译出的程序运行效率更高 Tools 使用 LLVM 的一些优化和绘图都针对 bitcode 文件，这里介绍与之相关的工具使用
从 源文件 生成 bitcode 文件
clang -c -emit-llvm const.c -o const.bc clang 是 LLVM 的前端编译工具，可以用它来生成目标文件，这个指令将 .c 代码生成 .bc 文件.
warning: 使用这个命令的时候会自动带有 -O0 级别的优化（新版本中），可以禁止它，参考
clang -c -emit-llvm -Xclang -disable-O0-optnone const.c -o const.bc llvm tools 提供了产生 cfg callgraph 等图片参数的工具（opt），注意，不会自己生成图片，还需要工具（如：graphviz MacOS下安装 brew install graphviz） cfg 图</description></item><item><title>runtime</title><link>https://blog.airchen-space.top/posts/runtime/</link><pubDate>Tue, 03 Dec 2019 17:19:51 +0800</pubDate><guid>https://blog.airchen-space.top/posts/runtime/</guid><description>运行时的继续研究 + 笔记中的上半部分
@interface TObject : NSObject + (instancetype)getT; @end @implementation TObject + (instancetype)getT { return [TObject new]; } + (NSArray *)array { return [NSArray new]; } + (NSNumber *)number { return [NSNumber new]; } + (NSPredicate *)p { return [NSPredicate new]; } @end int main(int argc, const char * argv[]) { @autoreleasepool { _objc_autoreleasePoolPrint(); __auto_type obj = [TObject getT]; // autorelease _objc_autoreleasePoolPrint(); __auto_type predicate = [TObject p]; // autorelease _objc_autoreleasePoolPrint(); __auto_type arr = [TObject array]; // LTS _objc_autoreleasePoolPrint(); __auto_type num = [TObject number]; // LTS _objc_autoreleasePoolPrint(); } _objc_autoreleasePoolPrint(); return 0; } 测试返回值的内存管理 有些事放在 autorelease里，有些事在 LTS 里</description></item><item><title>Metal 基础实践</title><link>https://blog.airchen-space.top/posts/metalbase/</link><pubDate>Sun, 20 Jan 2019 17:19:51 +0800</pubDate><guid>https://blog.airchen-space.top/posts/metalbase/</guid><description>简介 Metal 提供了和 GPU 的底层交互，让开发者可以使自己的iOS、macOS、tvOS应用表现出最佳的图形和运算处理性能。该文章从苹果官方提供的机组 demo 入手，介绍 MetalKit 和 Metal Shading Language 的使用，并使用它们进行图形渲染和科学计算。
MetalKit使用的基本步骤 第一个最重要的类是 MTKView ,这是一个包裹了 UIView 或者 NSView 的对象，具备 Metal-spcific 的核心动画功能，渲染的内容在 MTKView 上进行显示。MTKView 比较重要的属性是 preferredFramesPerSecond 、device 和 delegate 。
preferredFramesPerSecond 毋庸置疑是用来设置帧率的，这个帧率不是绝对的，会受限与设备的最大帧率和最小帧率，当这个值大于最大帧率，则选择最大帧率；小于最小帧率，则选择最小帧率。其默认值为 60 。
device 用来获取 Metal 与 GPU 交互的一系列对象，默认值是 nil ，需要使用 MTLCreateSystemDefaultDevice() 来主动获取。
delegate 具备了 MTKViewDelegate ，其提供 mtkView:drawableSizeWillChange: 和 drawInMTKView: 回调。每刷新一帧 drawInMTKView: 回调会被调用一次，在 drawInMTKView: 里面可以进行绘制或者计算相关的工作；mtkView:drawableSizeWillChange: 回调是在 MTKView 的 frame 发生改变的时候回调，可以手机发生屏幕旋转或者其他需要调整视图的操作时，调整绘制区域。
第二类是 Metal 与 GPU 交互相关的对象 如图是一个绘制的基本流程：
我们需要一个具备 MTLCommandQueue 协议的对象，其负责在每一帧里生产一系列具备 MTLCommandBuffer 协议的对象，Metal 与 GPU 的交互都会被写入到这些具备 MTLCommandBuffer 协议的对象里面，而这个写入的过程需要通过一个具备 MTLXXXCommandEncoder（MTLRenderCommandEncoder、MTLComputeCommandEncoder 或者其他的Encoder）协议的对象。</description></item><item><title>浅谈代码优化</title><link>https://blog.airchen-space.top/posts/cleancode/</link><pubDate>Sat, 21 Jul 2018 17:19:51 +0800</pubDate><guid>https://blog.airchen-space.top/posts/cleancode/</guid><description>文章结构
1. 实例 2. 引经据典 3. 总结 实例 首先引入一个代码优化的实例，请参读以下代码：
{% highlight objc %}
(void)sdkAuthSetServerUrlBase:(NSString *)url isAuthTest:(NSNumber *)test { if (test.boolValue) { _isSDKAuthTest = test.boolValue; if (url &amp;amp;&amp;amp; url.length &amp;gt; 0) { SdkAuth_setServerUrlBase([url cStringUsingEncoding:NSUTF8StringEncoding]); } } else { if (!_isSDKAuthTest) { if (url &amp;amp;&amp;amp; url.length &amp;gt; 0) { SdkAuth_setServerUrlBase([url cStringUsingEncoding:NSUTF8StringEncoding]); } } _isSDKAuthTest = test.boolValue; } } {% endhighlight %} 代码格式整齐，变量和函数名命名规范，可以从第一眼看下去，能难理清楚其中的逻辑。该函数是一个供内部测试使用的接口，有两个标准位进行控制。 首先可以把函数的大致逻辑理清楚一下，其主要功能应该是设置sdkAuth的url，于是先把设置url的功能单独拿出来一下，这是在url存在而且有效的时候进行设置，于是函数可以调整为如下：
{% highlight objc %}
(void)sdkAuthSetServerUrlBase:(NSString *)url isAuthTest:(NSNumber *)test { if (test.</description></item><item><title>画出你的项目架构图</title><link>https://blog.airchen-space.top/posts/architecture/</link><pubDate>Tue, 01 May 2018 17:19:51 +0800</pubDate><guid>https://blog.airchen-space.top/posts/architecture/</guid><description>近期在工作之余阅读了一本架构方面的书籍，《软件架构》，由国际知名架构师Simon Brown编写，国内邓刚翻译。全书200多页，分为了68个章节，8个部分，每个章节一到两页，全书阅读下来并不会花太多时间。相比较一些软件架构方面的大厚本，此书比较适合作为一部架构方面的入门书籍，阅读完此书，可以对架构师这个职业角色有个清晰的认识。
全书的第四部分，介绍了关于软件可视化的一些方案，感觉非常实用。在日常的项目开发过程中，会面临团队合作，部门间合作等问题，不同个体之间的合作，自然避免不了要做技术上的沟通。在缺少文档的时候，一副可以提现各个模块之间联系的架构图可以很好地提现项目整体逻辑，提高技术沟通的有效性。书中有介绍一种C4的模型，具有很强的表达性和制作简洁等优势，本文将详细介绍这个模型。
C4模型将软件系统分成：系统、容器、组件和类。系统即软件系统，一般需给出其具体的使用环境和需要解决的需求，在其之下会有一系列的容器；容器是一个个单独的可执行文件，负责其固定的功能，在每个单独的容器会有一系列的组件来构成该容器；组件是应用程序中的功能模块，每个组件负责各自单独的功能，最后为了实现该组件的特定功能，会有一系列的类来实现这个组件。总体的结构示意图如下：
根据场景的不同，可以将C4模型中的四个部分对应为：语境图（Context）、容器图（Container）、组件图（Component）和类图（Code），这也是C4模型名字的由来。
语境图 系统语境图是绘制一个软件系统的开始。在一个方框的中间画出系统，系统周围画出一些与之交互的使用者和其他功能系统。
在语境图中，不必详细的展示每个细节，需要更加关注于人和软件系统的关系，而不是技术细节和实现原理。语境图应该是一种可以展示给非技术人员看的图。
范围：一整个软件系统
关键元素：范围内的软件系统 辅助元素：范围内的人和软件系统之间的联系
受众：每个人，包括技术和非技术人员，软件开发团队内的人和团队外的人
容器图 一旦你理解软件系统适用的IT环境，真正有益的下一步是关注于系统周边的容器图。一个容器可以是一个：服务器端的web应用、单页面的应用程序、桌面应用程序、移动端APP、数据库方案、文件系统等等。基本特征是，容器是一个独立的可运行程序或者可部署单元。
容器图展示的软件的高层次组织结构，同时也展示了主要技术的选择和容器之间的交互。这是一种简单的高层技术选型的图，但对软件开发人员很有用。
范围：单独的软件系统
主要元素：软件系统内的各个容器 辅助元素：和容器相关的人和软件系统之间的联系
受众：软件系统开发团队相关的技术人员，包括了：架构师、开发者和技术支持人员
注意：该图不需要介绍部署场景、集群、复制和故障转移等等
组件图 组件图展示的是一个容器内部是如何组织各个组件的，一个组件即容器内部的一个功能和技术实现细节。
范围：单个容器
主要元素：容器范围内的各个组件 辅助元素：容器、和组件相关的人和软件系统的联系
受众：架构师和开发者
类图 类图是单个组件的实现代码组织，可以用类似UML图、整体关系图来表示。
这是一种可选的图，通常情况下可以用IDE和UML模型工具自动生成，你应该思考的是需要暴露类的那些属性和接口来表示这个组件的功能。类图不推荐制作，除非组件的功能逻辑相当复杂。
范围：单个组件
主要元素：组件范围内的代码元素，如：类、接口、对象、函数、基础表格等等。
受众：架构师和开发者
总结 C4模型主要通过“抽象first”的方式来绘制架构图，通过基于上层的抽象反应出软件系统的结构，同时也体现了开发者对于软件系统的思考，这种基于子集的抽象和分层的方式使C4模型非常容易学习和使用。
在软件项目需要与拟出一份技术文稿的时候，可以先试试将软件系统绘制成一个个架构图，来梳理其结构。
参考资料 C4模型官网
程序员必读之软件架构</description></item><item><title>iOS知识点杂记</title><link>https://blog.airchen-space.top/posts/tips1/</link><pubDate>Sun, 15 Apr 2018 17:19:51 +0800</pubDate><guid>https://blog.airchen-space.top/posts/tips1/</guid><description>有很长一段时间没有更新自己的blog了，期间有春节假期、春节假期之前的忙、春节假期之后的懒，不得不承认自己是个不折不扣的懒癌晚期患者😂。其实年后，在工作上的任务也有所调整的，之前有很长一段时间是做iOS SDK的封装，及底层移植层的开发，年后不久组老大启动了我们团队自己的APP开发计划（我们团队是负责GIS地图引擎开发团队）。我也着手开始开发APP，期间组内招了一个iOS小伙伴，这个APP的iOS端也就由我们两人负责开发。
在开发过程中，我也在不断的梳理自己在iOS开发方面的技术点，并打算定期更新自己的博客，与读者一起分享在这APP开发过程中的一些坑。
List UILabel的自动换行： _addressLabel.numberOfLines = 0; _addressLabel.lineBreakMode = NSLineBreakByWordWrapping; 计算字符串高度:
UILabel 方法 - (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize; UIView 方法 - (CGSize)sizeThatFits:(CGSize)size; NSString 方法 - (CGRect)boundingRectWithSize:(CGSize)size options:(NSStringDrawingOptions)options attributes:(NSDictionary&amp;lt;NSString *,id&amp;gt; *)attributes context:(NSStringDrawingContext *)context; UITableView顶格，去掉最上面一行的间隔 self.tableView.tableHeaderView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, CGFLOAT_MIN)]; XCode9 使用rename的时候，出现 &amp;lsquo;rename failed&amp;rsquo; 情况时 1.关闭XCode
2.进入文件夹 ~/Library/Developer/Xcode/DerivedData/，删除文件夹下的所有文件
3.启动XCode
或者可以直接用终端输入：
rm -rf ~/Library/Developer/Xcode/DerivedData/* XCode重启即可
UICollectionView数据不够时，不能竖向滑动 UICollectionView 的属性bounces 默认的水平方向的滑动设置，其实还有alwaysBounceVertical 和alwaysBounceHorizontal属性，alwaysBounceHorizontal 和bounces 的效果一致，如果是竖向可以使用alwaysBounceVertical属性
UICollectionView在一个frame 动画之后，调用setContentOffset 没有作用，不能改变里面内容的位置，这个时候，应该把setContentOffset 方法也放入一个动画中去调用。
NSTimer的循环圈 调用NSTimer 的scheduledTimerWithTimeInterval: target: selector: userInfo: repeats: 来初始化一个NSTimer对象时，有可能会产生循环引用。可以使用scheduledTimerWithTimeInterval:repeats:block: 方法。</description></item><item><title>斯坦福机器学习课程(一)</title><link>https://blog.airchen-space.top/posts/ml_part1/</link><pubDate>Sat, 13 Jan 2018 17:19:51 +0800</pubDate><guid>https://blog.airchen-space.top/posts/ml_part1/</guid><description>机器学习的两种定义： 来自Arthur Samuel 的表述: &amp;ldquo;the field of study that gives computers the ability to learn without being explicitly programmed.&amp;ldquo;这是一种古老的非正式的定义。 Tom Mitchell 提供的一种现代化的定义: &amp;ldquo;A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.&amp;rdquo; 举个例子，跳棋游戏
E = 玩跳棋的经验
T = 下跳棋的过程
P = 下场跳棋获胜的可能性</description></item><item><title>iOS GCD知识点总结</title><link>https://blog.airchen-space.top/posts/gcd_about/</link><pubDate>Sun, 07 Jan 2018 17:19:51 +0800</pubDate><guid>https://blog.airchen-space.top/posts/gcd_about/</guid><description>引入 GCD(Grand Central Dispatch)是苹果从OS X Snow Leopard 和 iOS4 开始引入的一套多线程开发的API，它是基于C语言的实现，其执行效率对比其他的多线程实现方式更高。其接口的调用很简洁，使用起来十分方便。用苹果爸爸的话来说，那就是：
开发者要做的只是定义想执行的任务并追加到适当的Dispatch Queue
既然有这么好的东西在这里，为什么不好好地去使用它呢？
梳理点 多线程把原本顺序执行的程序变成了多个流程来执行，各个流程之间的切换会有性能消耗，但在GCD的时候，永远不用关注这些底层的事情。 苹果爸爸说的那句话是追加，并不是执行，所以在需要考虑执行效率的地方使用GCD接口，一定要记住是追加，追加后并不一定是立刻就执行！！！
在iOS6以后的版本，不用考虑dispatch_release()和dispatch_retain()的调用时机，系统以及将其交给ARC来处理。
Dispatch Queue分为两类，串行队列和并行队列，都是按照追加顺序执行，但一个串行队列总在一个线程中执行，会有等待，并行队列会发起多线程并发执行，没有等待。
Dispatch Queue可以通过dispatch_queue_create来创建，也可以从系统中来获取，系统提供了两类队列：Main Dispatch Queue 和 Global Dispatch Queue,其中Main Dispatch Queue是串行队列，Global Dispatch Queue是并行队列，同时提供四个执行等级。
创建多个串行队列来操作同一个资源，会有数据竞争问题，用一个并行队列来操作，不会造成多线程安全问题，并且多个并行队列也不会。
dispatch_sync指定一个串行队列，会造成死锁。
dispatch_apply会有阻塞线程问题，必须规定次数的block执行完，才走之后的代码。
dispatch_walltime可用来创建绝对时间dispatch_time_t，相比dispatch_time创建的相对时间，绝对时间可用来做定时器。dispatch_time_t可用于dispatch_delay 和 dispatch_group_wait函数。
{% highlight objc %} dispatch_time_t getDispatchTimeByDate(NSDate *date) { NSTimeInterval interval; double second, subsecond; struct timespec time; dispatch_time_t milestone;</description></item><item><title>深入CocoaLumberjack日志系统</title><link>https://blog.airchen-space.top/posts/cocoa-lumberjack/</link><pubDate>Mon, 01 Jan 2018 17:19:51 +0800</pubDate><guid>https://blog.airchen-space.top/posts/cocoa-lumberjack/</guid><description>引入 在iOS开发中，日志系统是很重要的一个部分，尤其是在修复代码中的bug，通常会用NSLog来将这些信息打印到XCode控制台中显示，但在日志信息较多的时候，会出现一些性能上的问题。因为NSLog在使用的时候占用资源较多，其设计也是基于ASL(Apple System Log)的高层封装，针对error log。所以在对性能要求较高的地方，不能用NSLog进行调试。
作为NSLog的替代，CocoaLumberjack是一款优秀的第三方日志系统。官方的介绍如下：
CocoaLumberjack is a fast &amp;amp; simple, yet powerful &amp;amp; flexible logging framework for Mac and iOS. It is similar in concept to other popular logging frameworks such as log4j, yet is designed specifically for Objective-C, and takes advantage of features such as multi-threading, grand central dispatch (if available), lockless atomic operations, and the dynamic nature of the Objective-C runtime. 支持用CocoaPods和Carthage部署到项目中，当前的系统要求如下：
在设计中，CocoaLumberjack使用了大量的GCD语法，使性能更好；宏定义的使用，让API接口语法更加简便；加上整体架构的设计独特，使这套第三方日志系统更利于根据一些特殊需求来定制功能。
代码分析 使用CocoaLumberjack的时候，会引用其头文件，Oc的项目引用CocoaLumberjack.h，swift项目CocoaLumberjack.swift。
这里，我们从CocoaLumberjack.h展开，文件开头给出了大段的注释信息，详细介绍了关于该日志系统的使用(在该源码的其他头文件中，同样可以看到消息的注释信息，对该接口甚至类的设计进行解说，可见一套优秀的开源项目在细节上是做的多么细致，值得学习！)，随后，引入了一系列的头文件：</description></item><item><title>一种支持多线程并发读写的数据模型</title><link>https://blog.airchen-space.top/posts/networkstream/</link><pubDate>Sun, 03 Dec 2017 17:19:51 +0800</pubDate><guid>https://blog.airchen-space.top/posts/networkstream/</guid><description>在实际的开发中，常常会遇到这种场景，一个模块产生数据，另外一个模块处理数据。无论是为了模块间的解耦或者是并发处理，我们都会在生成和处理数据的模块之间放置缓存区，作为生成与处理之间的数据仓库。这类模型就是生产者与消费者模型。
生产者和消费者往往是并发的多个线程，它们可能同时对一块数据进行增加与删除操作。一个比较常见的情形是在对网络数据的处理上，我们想把从网络下载的数据进行一个高效的处理，又不想保存在本地磁盘上。这个时候就会考虑用一个内存变量对数据进行缓存，同时需要满足以下这些条件：
线程安全，不能让一个线程正在对数据进行操作的时候，被其他线程打断。 在数据被处理完后，变量要及时被释放，减少内存占用。 写入操作快于读出操作时，要限制一个最大的变量空间并阻塞写入线程，等待读出操作，防止内存占用过大，将app杀死。 读出操作快于写入操作时，要在数据为空时，阻塞读出线程，等待写入线程的数据写入。 根据这些要点，本文设计了一种高效的数据仓库，该数据仓库可以对二进制数据进行线程安全的读写操作，读出数据后，立马释放读出的资源，内存占用少，没有磁盘操作，所以效率会很高。
仓库链接
该数据仓库的主体以一个可变数组组成，数组中的每个元素为一定长的二进制数据NSData，通过读标志位和写标志位，记录该结构体类数据的读写状态，当数据被读出，且正好凑出整数个NSData，则将这些NSData的内存进行释放，更新读写标志位。
{:width=&amp;ldquo;70%&amp;rdquo; height=&amp;ldquo;70%&amp;rdquo; align=&amp;ldquo;center&amp;rdquo;}
这里起关键性作用的是记录读写状态的读写标志位，它们分为readIndex、readInnerIndex、writeIndex和writeInnerIndex，刚开始数据仓库中没有数据时，各个状态为赋值为-1。当开始写入数据，该数据结构会根据写入数据的长度计算出一个结束的位置，然后在结束为与当前的writeIndex和writeInnerIndex之间，写入数据。最后用结束位更新写标志位。
读操作与写操作类似，会先根据读长度来计算出一个读出结束标志位，然后把当前读标志位到读出结束标志位之间的数据写入一个读出的buffer，凑齐整数个NSData则删除，最后用读出结束标志位来更新度标志位，同时更具数组中删除的NSData个数，调整读写标志位中的XXIndex标志位。
同步锁使用的@synchronized，在数据读完后，有加等待，让数据继续写入，直到写入线程结束。</description></item><item><title>APP瘦身 - 之framework</title><link>https://blog.airchen-space.top/posts/framework_thin/</link><pubDate>Sun, 05 Nov 2017 17:19:51 +0800</pubDate><guid>https://blog.airchen-space.top/posts/framework_thin/</guid><description>在大型项目的开发中，我们常常会对一些功能比较固定的模块进行封装打包成静态库，以提供给他人使用。但在一般的打包中，得到的framework体积都比较大，这样会导致最后开发出来的APP，体积会过大，用户从App Store下载时，消耗大量的时间和流量，最终影响用户体验。
当我们决定要将一个工程打包成framework供他人使用时，通常支持的指令集有i386、x86_64、armv7、arm64，其中armv7和arm64为供真机的指令集，i386和x86_64电脑端的指令集。往往我们打出来的包，是可以供支持电脑端和真机使用的，通常这样的framework体积会比较大。如果单独，将包分成真机部分和电脑虚拟机部分，会节省出很大的一笔空间。
lipo 是一个在 Mac OS X 中处理通用程序（Universal Binaries）的工具。使用lipo，我们可以将framework中的静态库，进行分割。 以下是一些常用指令：
查看静态库支持的CPU架构 lipo -info libname.a(或者libname.framework/libname) 合并静态库 lipo -create 静态库存放路径1 静态库存放路径2 ... -output 整合后存放的路径 lipo -create libname-armv7.a libname-armv7s.a libname-i386.a -output libname.a framework 合并(例util.framework)
lipo -create arm7/util.framework/util i386/util.framework/util -output util.framework 静态库拆分 lipo 静态库源文件路径 -thin CPU架构名称 -output 拆分后文件存放路径 架构名为armv7/armv7s/arm64等，与lipo -info 输出的架构名一致
lipo libname.a -thin armv7 -output libname-armv7.a 对framework进行瘦身的方案可以如下：
//找到framework中的静态文件staticLib //分别打包出各个平台的库 lipo staticLib -thin armv7 -output staticLib_armv7 lipo staticLib -thin arm64 -output staticLib_arm64 lipo staticLib -thin i386 -output staticLib_i386 lipo staticLib -thin x86_64 -output staticLib_x86_64 //分别组合出真机平台，和电脑虚拟机平台的包 lipo -create staticLib_armv7 staticLib_arm64 -output staticLib_iphone lipo -create staticLib_i386 staticLib_x86_64 -output staticLib_iphonesimulate 关键代码可以用Python进行包装，方便以后调用。</description></item><item><title>MacOS下Hadoop环境搭建</title><link>https://blog.airchen-space.top/posts/hadoopmacos/</link><pubDate>Sat, 22 Jul 2017 17:19:51 +0800</pubDate><guid>https://blog.airchen-space.top/posts/hadoopmacos/</guid><description>安装 Homebrew是MacOs系统下一款强大的软件包管理工具，通过它可以安装git、wget等工具，同样Hadoop的安装也可以通过它来进行：
brew install hadoop 这样hadoop被安装在系统的 /usr/local/Cellar/hadoop 目录之下。
配置 hadoop安装后，提供三种运行模式：
独立模式 伪分布模式 完全分布式 以下是《Hadoop权威指南》对这三种模式的解释：
Standalone (or local) mode There are no daemons running and everything runs in a single JVM. Standalone mode is suitable for running MapReduce programs during development, since it is easy to test and debug them. Pseudodistributed mode The Hadoop daemons run on the local machine, thus simulating a cluster on a small scale. Fully distributed mode The Hadoop daemons run on a cluster of machines.</description></item><item><title>UICollectionViewFlowLayout相关</title><link>https://blog.airchen-space.top/posts/flowlayout/</link><pubDate>Sun, 05 Feb 2017 17:19:51 +0800</pubDate><guid>https://blog.airchen-space.top/posts/flowlayout/</guid><description>子类化UICollectionViewFlowLayout可以让UICollectionView实现许多精彩的布局，在实际的项目中子类化UICollectionViewFlowLayout得到了广泛的应用。
引入 以下是一些实例：
可见借助于UICollectionViewFlowLayout可以让UICollectionView展示丰富的界面效果。
基本用法 涉及到的类有：
UICollectionViewFlowLayout =&amp;gt; 负责item的布局，也可实现切换item的动画 UICollectionView =&amp;gt; 展示的总视图 UICollectionViewCell =&amp;gt; 每个item 协议有：
UICollectionViewDelegate UICollectionViewDataSource 用已经子类化的UICollectionViewFlowLayout创建一个UICollectionView
self.collectionView = [[UICollectionView alloc] initWithFrame:CGRectZero collectionViewLayout:self.smallLayout]; 在数据源方法中实现item的数量与每个item的创建
- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section; - (__kindof UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath; 其中UICollectionViewCell可以子类化，添加一些label或者ImageView。
可以简单的子类化一个UICollectionViewFlowLayout，只需复写以下init方法：
-(id)init { if (!(self = [super init])) return nil; self.itemSize = CGSizeMake(30, 30); self.sectionInset = UIEdgeInsetsMake(10, 10, 10, 10); self.minimumInteritemSpacing = 10.0f; self.minimumLineSpacing = 10.0f; return self; } 此外UICollectionViewFlowLayout还包括一些其他的方法，可以根据需求来选择：</description></item><item><title>About Me</title><link>https://blog.airchen-space.top/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.airchen-space.top/about/</guid><description>个人信息 任志琛 男 30岁 工作经验 5年 工作经历 北京百度网讯科技有限公司 C++ 地图服务 2021年8月 至今 北京四维图新科技股份有限公司 C++ 地图引擎开发 2018年4月 2021年8月 北京四维智联科技有限公司 iOS SDK开发 2017年7月 2018年4月 教育经历 研究生 广西师范大学 电子科学与技术 本科 北京邮电大学世纪学院 通信工程 联系我 邮箱 renzhichen2012@163.com qq 252199456</description></item><item><title>今日资讯</title><link>https://blog.airchen-space.top/daily/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.airchen-space.top/daily/</guid><description>个人博客 科技爱好者周刊（第 203 期）：英国的名校签证，伯克利的计算机教育 read
科技爱好者周刊（第 202 期）：三个有启发的学习方法 read
蒙皮数据的压缩 read
Lua binding 中正确的 callback read
全民大规模新冠检测方案的一些想法 read
一个付费 chrome 插件的一生 read
通过 GitHub 订阅 Hacker News 每日 top 10 read
让用户决定软件长什么样 read
某一天，中国真会超过美国吗？ read
自定义C/C++日志输出函数 read
再聊 Git Flow read
IT团队博客 走向匿名化，谈谈微信小程序新授权登录 read
yield 学习 read
callable-object read
奇舞周刊第 442 期 read
奇舞周刊第 441 期 read
奇舞周刊第 440 期 read
VS Code 是如何优化启动性能的？ read
服饰3D柔性渲染调研及实践 read
业务系统的稳定性建设 read
[原]实战！如何从零搭建10万级 QPS 大流量、高并发优惠券系统 read</description></item></channel></rss>